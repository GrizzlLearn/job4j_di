Http протокол:
1. Расскажите, чем отличается UDP от TCP/IP.
    TCP/IP:
    - гарантирует что получатель получит все отправленные данные, т.к. каждый пакет проходит через тройное рукопожатие:
    SYN -> SYN/ACK -> ACK
    - Контроль ошибок, повторная отправка пакетов в случает потерь или повреждений + соблюдения порядка пакетов
    - медленнее, т.к. имеются накладные расходы на установку соединения + тратится время на достижение максимальной
    пропускной способности получателя
    - используется в HTTP/HTTPS, SMTP, FTP и тд

    UDP:
    - нет гарантий доставки пакетов
    - нет контроля ошибок
    - за счет отсутствия накладных расходов - очень быстрый
    - используется в стримминге, VoIP, DNS запросы и тд.

    Когда TCP быстрее UDP (Раздел "Особенности двух транспортных протоколов")
    https://habr.com/ru/companies/ruvds/articles/598615/
---
---

2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.
    GET:
    •	GET-запрос отправляется с минимальной информацией в заголовках. Заголовок содержит основную информацию, такую как:
    	•	Request-Line: указывает метод (GET), путь к ресурсу и версию протокола HTTP.
    	•	Host: указывает домен сервера.
    	•	User-Agent: информация о клиенте, который делает запрос.
    	•	Accept: указывает типы данных, которые клиент может обработать (например, text/html, application/json).
    	•	Cache-Control: директивы управления кэшированием.
    	•	Authorization: если требуется аутентификация, заголовок будет содержать данные для авторизации.
    	•	Cookies: отправка сессий или другой информации в виде куки-файлов.
    •	Тело:
    	•	GET-запросы не имеют тела. Вся информация, необходимая для обработки запроса, передается через URL
    	(например, параметры в строке запроса ?key=value).

    POST:
    •	POST-запросы имеют более сложные заголовки, так как предполагается передача данных на сервер. Основные заголовки:
    	•	Request-Line: метод (POST), путь и версия HTTP.
    	•	Host, User-Agent, Accept: те же, что и в GET-запросах.
    	•	Content-Type: определяет тип данных, передаваемых в теле запроса
    	(например, application/json, application/x-www-form-urlencoded, multipart/form-data).
    	•	Content-Length: указывает длину тела запроса.
    	•	Authorization, Cookies: аналогично GET-запросу, если требуется.
    •	Тело:
    	•	В теле POST-запроса передаются данные, которые сервер должен обработать. Это может быть:
    	•	JSON: { “key”: “value” }
    	•	Форма (application/x-www-form-urlencoded): key=value&key2=value2
    	•	Файлы (multipart/form-data): используется для отправки файлов на сервер.
    PUT:
    •	Заголовки PUT-запроса схожи с заголовками POST-запроса, поскольку PUT также используется для передачи данных на сервер.
    	•	Request-Line: метод (PUT), путь и версия HTTP.
    	•	Host, User-Agent, Accept, Content-Type, Content-Length, Authorization, Cookies: аналогично POST-запросу.
    •	Тело:
    	•	PUT-запрос обычно используется для обновления существующего ресурса или создания нового.
    	В теле запроса передаются данные ресурса, которые будут заменены или созданы на сервере.
    	Структура данных такая же, как в POST (JSON, XML, и т.д.).
    	•	В отличие от POST, PUT-запрос предполагает идемпотентность, то есть повторный запрос с одинаковыми данными
    	не должен менять состояние ресурса.
    DELETE:
    •	Заголовки DELETE-запроса минимальны и аналогичны GET-запросу:
    	•	Request-Line: метод (DELETE), путь и версия HTTP.
    	•	Host, User-Agent, Accept, Authorization, Cookies: стандартные заголовки, как в GET-запросах.
    •	Тело:
    	•	DELETE-запрос обычно не имеет тела. Вся информация для удаления ресурса передается через URL
    	(например, идентификатор ресурса в пути).
    Типы HTTP-запросов и философия REST (Раздел "Ресурсы и методы")
    https://habr.com/ru/articles/50147/
---
---

3. Расскажите о статусах HTTP протокола.
    Статусов очень много, поэтому приведу основные:
    - 200 OK
    - 201 - часто используют вместо 200
    - 301 - если используется перенаправление
    - 400 - Bad Request
    - 401 - Unauthorized
    - 403 - Forbidden
    - 404 - Not Found
    - 405 - Method Not Allowed
    - 418 - крутая штука для сокрытия реальной кода
    - 500 - Internal Server Error
    - 502 - Bad Gateway
    - 503 - Service Unavailable
    - 504 - Gateway Timeout
    Список кодов состояния HTTP
    https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP
4. Расскажите о mime-type HTTP протокола.
    Я сталкивался только с двумя:
    application/json для отправки json и multipart/mixed - для отправки email
    Вообще их вот столько:
    application;
    audio;
    example;
    image;
    message;
    model;
    multipart;
    text;
    video.
    Список MIME-типов
    https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2

---
---

Веб-контейнер:
1. Что такое сервлет?
    Это интерфейс в java, взаимодействует с с клиентами посредством принципа запрос-ответ.

    Жизненный цикл сервлета состоит из следующих шагов:

    - В случае отсутствия сервлета в контейнере.
        1) Класс сервлета загружается контейнером.
        2) Контейнер создаёт экземпляр класса сервлета.
        3) Контейнер вызывает метод init(). Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет обслуживать запросы.
        За весь жизненный цикл метод init() вызывается только один раз.
    - Обслуживание клиентского запроса:
    Каждый запрос обрабатывается в своём отдельном потоке. Контейнер вызывает метод service() для каждого запроса.
    Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса.
    Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не реализован,
    вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
    - В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации.
    Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.
    Сервлет (Java) Wiki https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%BB%D0%B5%D1%82_(Java)
    Документация Servlet
---
---

2. Какова структура веб-проекта?
    в учебе мы используем следующую структуру:
    db/
    src/main/
        java/*/
            config
            controller
            model
            repository
            service
        resources/
            static
            templates
            props
    src/test
        java/*/packetsForTests
        resources/prop
    Introduction to the Standard Directory Layout
---
---

3. Что такое контейнер сервлетов?
    Это часть сервера приложений или веб-сервера, которая управляет жизненным циклом сервлетов,
    обеспечивает их взаимодействие с клиентами и окружением, а также предоставляет различные возможности для разработки веб-приложений на Java.


    Популярные реализации контейнеров сервлетов:

    •	Apache Tomcat
    •	Jetty
    •	GlassFish
    •	WildFly (бывший JBoss)

    Контейнер сервлетов Wiki
    https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B5%D1%80%D0%B2%D0%BB%D0%B5%D1%82%D0%BE%D0%B2

    ---
    ---

4. Каковы задачи, функциональность контейнера сервлетов?

    Основные функции контейнера сервлетов:
    1.	Управление жизненным циклом сервлетов: Контейнер создает, инициализирует, обрабатывает запросы и уничтожает сервлеты. Он контролирует все этапы работы сервлета — от его создания до завершения работы.
    2.	Обработка HTTP-запросов: Контейнер принимает HTTP-запросы от клиента (например, веб-браузера), передает их соответствующему сервлету для обработки и возвращает ответ клиенту.
    3.	Управление потоками: Контейнер автоматически создает потоки для обработки каждого запроса, что позволяет сервлетам обрабатывать несколько запросов одновременно.
    4.	Управление безопасностью: Контейнер может контролировать доступ к веб-ресурсам через различные механизмы аутентификации и авторизации (например, использование SSL, ограничение доступа к страницам и т.д.).
    5.	Поддержка сессий: Контейнер сервлетов может управлять сессиями пользователей, отслеживая информацию о пользователях между различными запросами (например, используя cookies или идентификаторы сессий).
    6.	Портируемость и стандарт: Сервлеты работают в соответствии с Java Servlet API, что обеспечивает переносимость веб-приложений между различными сервлет-контейнерами.
---
---

5. Что вы знаете о сервлет фильтрах?

    Это компоненты Java Servlet API, которые позволяют перехватывать и обрабатывать запросы и ответы, проходящие через
    веб-приложение, до того, как они достигают сервлетов или других конечных точек.
    Фильтры используются для выполнения различных задач, таких как аутентификация, логирование, сжатие данных и другие
    операции, которые должны выполняться до или после основного процесса обработки запроса.

    Основные характеристики и задачи фильтров:
	1.	Предобработка запросов: Фильтры могут изменять или логировать данные запроса, например, проверять заголовки,
	параметры или содержимое тела запроса, прежде чем передать его сервлету.
	2.	Постобработка ответов: После того как сервлет завершил обработку, фильтры могут изменять или анализировать ответ,
	например, сжимать данные, добавлять заголовки или вести аудит.
	3.	Цепочка фильтров: Несколько фильтров могут быть связаны друг с другом в цепочку. Каждый фильтр может передавать
	запрос следующему фильтру в цепочке или напрямую конечному компоненту (например, сервлету).
	Это позволяет организовывать обработку в несколько этапов.

    Жизненный цикл фильтров:

    1.	Инициализация (init): Фильтр инициализируется контейнером при запуске приложения.
        Это метод, в котором можно настроить начальные параметры.
    2.	Фильтрация запроса (doFilter): Это основной метод фильтра, который вызывается при каждом запросе. Фильтр может:
        •	изменить запрос,
        •	отклонить его,
        •	передать дальше по цепочке фильтров или непосредственно в сервлет,
        •	обработать ответ после вызова сервлета.
    3.	Уничтожение (destroy): Этот метод вызывается, когда фильтр выгружается из памяти. Обычно это используется для очистки ресурсов.

    Основные задачи фильтров:

    1.	Аутентификация и авторизация: Проверка, имеет ли пользователь права на доступ к ресурсу.
    2.	Логирование и аудит: Сбор информации о запросах и ответах (время, параметры и т.д.).
    3.	Сжатие данных: Сжатие ответов сервера для оптимизации передачи данных (например, использование GZIP).
    4.	Кэширование: Управление кэшированием данных для оптимизации производительности.
    5.	Перенаправление и изменение запросов: Изменение маршрута запроса, добавление или изменение параметров.

    Использование фильтра сервлетов для «всплытия» страницы из фрейма
    https://habr.com/ru/articles/141866/
    The Essentials of Filters
---
---

6. Зачем нужны слушатели в сервлетах?
    Это компоненты, которые отслеживают события в жизненном цикле веб-приложения и выполняют определенные действия в
    ответ на эти события.

    Основные задачи слушателей:

    1.	Инициализация ресурсов: Слушатели могут инициализировать необходимые ресурсы при запуске веб-приложения (например, соединение с базой данных, пул потоков).
    2.	Освобождение ресурсов: При завершении работы приложения слушатели могут закрывать соединения, освобождать память или выполнять другие операции очистки.
    3.	Мониторинг сессий: Слушатели могут отслеживать создание и уничтожение пользовательских сессий, что полезно для управления данными сессий, аутентификацией и персонализацией контента.
    4.	Логирование событий: Слушатели можно использовать для ведения логов ключевых событий приложения, таких как запросы, изменения в сессиях или изменения атрибутов.
    5.	Обработка событий в запросах: Можно отслеживать моменты начала и окончания обработки запросов для выполнения задач, связанных с безопасностью или оптимизацией.

    Типы слушателей:

    1.	ServletContextListener: Отслеживает события, связанные с жизненным циклом контекста веб-приложения (инициализация и завершение работы).
    2.	HttpSessionListener: Отслеживает создание и завершение сессий пользователей.
    3.	ServletRequestListener: Отслеживает события, связанные с жизненным циклом запросов.
    4.	ServletContextAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в контексте веб-приложения.
    5.	HttpSessionAttributeListener: Отслеживает изменения атрибутов сессий.
    6.	ServletRequestAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в запросах.

---
---

7. Когда вы будете использовать фильтры, а когда слушатели?

    •	Используйте фильтры, когда необходимо вмешаться в поток запросов и ответов: изменять, проверять или логировать запросы и ответы на уровне обработки HTTP.
    •	Используйте слушатели, когда нужно отслеживать события на уровне приложения, сессий или запросов, особенно для задач инициализации или управления состоянием.
---
---

8. Как обработать исключения, выброшенные другим сервлетом в приложении?
    1. try catch внутри сервлета
    2. фильтр для перехвата исключений
    3. Использование аннотации @WebServlet и атрибута errorPage

---
---
9. Что такое дескриптор развертывания?

    это конфигурационный файл в Java веб-приложениях, который определяет, как веб-приложение должно быть развернуто и
    настроено в контейнере сервлетов (например, в Tomcat или Jetty).
    Этот файл содержит информацию, которая используется сервером приложений для правильной настройки и работы веб-приложения.

    Дескриптор развёртывания Wiki

---
---

10. Как реализовать запуск сервлета с запуском приложения?
    1. В файле web.xml можно настроить параметр <load-on-startup>, который определяет порядок загрузки сервлета при старте приложения.
    2. Использование аннотации @WebServlet с параметром loadOnStartup
---
---

11. Что представляет собой объект ServletConfig?
    это интерфейс, который предоставляет конфигурационную информацию о конкретном сервлете. Объект ServletConfig передается
    контейнером сервлетов (например, Tomcat или Jetty) при инициализации сервлета и используется для передачи параметров
    инициализации, определенных для конкретного сервлета.
---
---

12. Что представляет собой объект ServletContext?

    это объект, предоставляемый контейнером сервлетов (например, Tomcat, Jetty), который представляет собой глобальную конфигурацию веб-приложения.
    Он позволяет сервлетам взаимодействовать с общими ресурсами и информацией, доступной всему веб-приложению, а не только одному конкретному сервлету
---
---

13. В чем отличия ServletContext и ServletConfig?

	•	ServletConfig: Предоставляет информацию и параметры для конкретного сервлета. Каждый сервлет имеет свой объект ServletConfig.
	•	ServletContext: Представляет все веб-приложение и предоставляет доступ к общим ресурсам и параметрам, которые могут использоваться всеми сервлетами в приложении.
---
---
14. Что такое Request Dispatcher?
    это интерфейс в Java Servlet API, который позволяет сервлетам взаимодействовать друг с другом.
    Он используется для перенаправления запросов или передачи управления другим сервлетам или ресурсам на сервере.

    Основные функции RequestDispatcher:

    	1.	Перенаправление запроса (forward):
    	    •	Текущий сервлет может передать управление другому ресурсу (сервлету, JSP или статическому ресурсу) на сервере.
    	    При этом управление полностью передается другому ресурсу, а клиент не будет знать, что запрос был перенаправлен.
    	2.	Включение содержимого другого ресурса (include):
    	    •	Можно включить результат обработки другого ресурса (например, другой сервлет или JSP-страница) в текущий ответ.
    	    Это позволяет объединять результаты разных ресурсов в один ответ.

    SP (JavaServer Pages) — это технология для создания динамических веб-страниц на Java, которая позволяет встраивать Java-код прямо в HTML-страницы.
    JSP страницы компилируются в сервлеты и обрабатываются сервером, что позволяет динамически генерировать HTML-контент на основе запросов пользователей и данных с сервера.

---
---
Thymeleaf:
1. Расскажите о назначении Thymeleaf?
    Удобный инструмент шаблонизации, явно удобнее чем рисовать страницы с JS

    Учебник Thymeleaf: Глава 1. Знакомство
---
---

2. Расскажите про тег th:text.

    th:text предназначен для динамической подстановки текста (или других данных) в HTML-элемент.
    В отличие от стандартного HTML-тега, который может выводить текст статически, th:text позволяет внедрить данные из
    контроллера или модели Spring, заменяя содержимое HTML-элемента.

    Как работает th:text:

    1.	Статический контент заменяется динамическим: Содержимое тега, где используется th:text, заменяется на значение,
    переданное в модель из контроллера. Это важно для предотвращения вывода статического содержимого и подмены его динамическими данными.
    2.	Обработка данных на стороне сервера: Тег th:text интерпретируется и заполняется на стороне сервера, а не клиента.
    Когда клиент получает готовую страницу, она уже содержит данные, сгенерированные на сервере.

    Учебник Thymeleaf: Глава 3. Использование Text
---
---

3. Расскажите про тег th:if.

    используется для условного отображения элементов на веб-странице.
    Он позволяет вывести элемент только в том случае, если заданное условие является истинным. Это аналог оператора if в java.

    еще есть тег th:unless, он является противоположностью th:if, т.е. производит проверку на false. т.е. отображает
    элемент если условие false.

    Особенности th:if:

    •	Полное удаление элемента: Если условие в th:if не выполняется (т.е. ложное), элемент полностью удаляется из DOM-структуры.
    Это делает его более производительным и удобным для использования, когда нужно скрыть элементы, которые не должны присутствовать на странице.

    Учебник Thymeleaf: Глава 7. Условное выполнение

---
---

4. Расскажите про тег th:href.

    используется для динамического формирования значений атрибута href в HTML-элементах, таких как ссылки (<a>) и другие теги,
    где требуется указать URL. Это позволяет подставлять URL-адреса на основе данных, полученных с сервера, или на основе логики,
    определенной в шаблоне.

    Учебник Thymeleaf: Глава 4. Standard Expression Syntax (Раздел "4.4. Link URL")

---
---

5. Расскажите про тег th:each.
    Учебник Thymeleaf: Глава 6.Итерации

---
---

6. Расскажите про тег th:object.
    Руководство: Thymeleaf + Spring. Часть 2 (Раздел "6.1 Обработка командного объекта")

---
---

7. Расскажите про тег th:action.
    Учебник Thymeleaf: Глава 5 Установка значений атрибутов (Раздел "5.2. Установка значения для определенных атрибутов")

---
---

Spring boot:
1. Опишите из каких компонентов состоит Spring boot?
    Введение в Spring Boot: создание простого REST API на Java
2. Что такое контроллер и как он связан с DispatcherServlet.
    Spring MVC — основные принципы (Раздел "DispatcherServlet")
3. Что такое стереотипные аннотации? Какие они бывают?
    Подготовка к Spring Professional Certification. Контейнер, IoC, бины (Вопрос "Что такое stereotypes")
4. Что такое DI? Как он реализован в Spring?
    Обратная сторона Spring
5. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam
    Spring MVC: создание веб-сайтов и RESTful сервисов (Разделы "@PathVariable" и "@RequestParam")
    Spring MVC: создание веб-сайтов и RESTful сервисов (Разделы "@GetMapping" и "Как вы можете управлять загрузкой файлов")
    Подготовка к Spring Professional Certification. Spring REST (Вопрос "Что за аннотации @GetMapping, @PostMapping")
Многопоточность:
1. Объясните, где в веб приложении появляется многопоточность?
    Конкуренция в сервлетах (Раздел "Обзор")
2. Как избежать проблем в многопоточности?
3. Как можно создать блокировку (deadlock) в сервлете?
4. Как решать проблемы многопоточности на уровне базы данных?
Архитектура:
1. Объясните слоеную архитектуру.
2. Объясните шаблон MVC на примере Servlet.
3. Объясните шаблон MVC на примере Spring boot.
    Spring MVC — основные принципы
База данных.
1. Зачем нужен пул соединений?
    Пулы соединений к БД — зачем и почему
Безопасность.
1. Что такое HttpSession?
    Spring MVC: создание веб-сайтов и RESTful сервисов (Раздел "Как получить доступ к текущей HttpSession пользователя")
    Документация HttpSession
2. Что такое авторизация?
    Авторизация Wiki
3. Что такое аутентификация?
    Аутентификация Wiki
4. Что такое cookie?
    «Осторожно, печеньки!»: советы начинающим тестировщикам в сфере безопасности (Раздел "Что хранят cookie")
    Cookie Wiki
6. Опишите аннотации @GetMapping, @PostMapping.
