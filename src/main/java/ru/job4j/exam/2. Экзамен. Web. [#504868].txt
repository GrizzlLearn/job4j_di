Http протокол:
1. Расскажите, чем отличается UDP от TCP/IP.
    TCP/IP:
    - гарантирует что получатель получит все отправленные данные, т.к. каждый пакет проходит через тройное рукопожатие:
    SYN -> SYN/ACK -> ACK
    - Контроль ошибок, повторная отправка пакетов в случает потерь или повреждений + соблюдения порядка пакетов
    - медленнее, т.к. имеются накладные расходы на установку соединения + тратится время на достижение максимальной
    пропускной способности получателя
    - используется в HTTP/HTTPS, SMTP, FTP и тд

    UDP:
    - нет гарантий доставки пакетов
    - нет контроля ошибок
    - за счет отсутствия накладных расходов - очень быстрый
    - используется в стримминге, VoIP, DNS запросы и тд.

    Когда TCP быстрее UDP (Раздел "Особенности двух транспортных протоколов")
    https://habr.com/ru/companies/ruvds/articles/598615/
---
---

2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.
    GET:
    •	GET-запрос отправляется с минимальной информацией в заголовках. Заголовок содержит основную информацию, такую как:
    	•	Request-Line: указывает метод (GET), путь к ресурсу и версию протокола HTTP.
    	•	Host: указывает домен сервера.
    	•	User-Agent: информация о клиенте, который делает запрос.
    	•	Accept: указывает типы данных, которые клиент может обработать (например, text/html, application/json).
    	•	Cache-Control: директивы управления кэшированием.
    	•	Authorization: если требуется аутентификация, заголовок будет содержать данные для авторизации.
    	•	Cookies: отправка сессий или другой информации в виде куки-файлов.
    •	Тело:
    	•	GET-запросы не имеют тела. Вся информация, необходимая для обработки запроса, передается через URL
    	(например, параметры в строке запроса ?key=value).

    POST:
    •	POST-запросы имеют более сложные заголовки, так как предполагается передача данных на сервер. Основные заголовки:
    	•	Request-Line: метод (POST), путь и версия HTTP.
    	•	Host, User-Agent, Accept: те же, что и в GET-запросах.
    	•	Content-Type: определяет тип данных, передаваемых в теле запроса
    	(например, application/json, application/x-www-form-urlencoded, multipart/form-data).
    	•	Content-Length: указывает длину тела запроса.
    	•	Authorization, Cookies: аналогично GET-запросу, если требуется.
    •	Тело:
    	•	В теле POST-запроса передаются данные, которые сервер должен обработать. Это может быть:
    	•	JSON: { “key”: “value” }
    	•	Форма (application/x-www-form-urlencoded): key=value&key2=value2
    	•	Файлы (multipart/form-data): используется для отправки файлов на сервер.
    PUT:
    •	Заголовки PUT-запроса схожи с заголовками POST-запроса, поскольку PUT также используется для передачи данных на сервер.
    	•	Request-Line: метод (PUT), путь и версия HTTP.
    	•	Host, User-Agent, Accept, Content-Type, Content-Length, Authorization, Cookies: аналогично POST-запросу.
    •	Тело:
    	•	PUT-запрос обычно используется для обновления существующего ресурса или создания нового.
    	В теле запроса передаются данные ресурса, которые будут заменены или созданы на сервере.
    	Структура данных такая же, как в POST (JSON, XML, и т.д.).
    	•	В отличие от POST, PUT-запрос предполагает идемпотентность, то есть повторный запрос с одинаковыми данными
    	не должен менять состояние ресурса.
    DELETE:
    •	Заголовки DELETE-запроса минимальны и аналогичны GET-запросу:
    	•	Request-Line: метод (DELETE), путь и версия HTTP.
    	•	Host, User-Agent, Accept, Authorization, Cookies: стандартные заголовки, как в GET-запросах.
    •	Тело:
    	•	DELETE-запрос обычно не имеет тела. Вся информация для удаления ресурса передается через URL
    	(например, идентификатор ресурса в пути).
    Типы HTTP-запросов и философия REST (Раздел "Ресурсы и методы")
    https://habr.com/ru/articles/50147/
---
---

3. Расскажите о статусах HTTP протокола.
    Статусов очень много, поэтому приведу основные:
    - 200 OK
    - 201 - часто используют вместо 200
    - 301 - если используется перенаправление
    - 400 - Bad Request
    - 401 - Unauthorized
    - 403 - Forbidden
    - 404 - Not Found
    - 405 - Method Not Allowed
    - 418 - крутая штука для сокрытия реальной кода
    - 500 - Internal Server Error
    - 502 - Bad Gateway
    - 503 - Service Unavailable
    - 504 - Gateway Timeout
    Список кодов состояния HTTP
    https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP
4. Расскажите о mime-type HTTP протокола.
    Я сталкивался только с двумя:
    application/json для отправки json и multipart/mixed - для отправки email
    Вообще их вот столько:
    application;
    audio;
    example;
    image;
    message;
    model;
    multipart;
    text;
    video.
    Список MIME-типов
    https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2

---
---

Веб-контейнер:
1. Что такое сервлет?
    Это интерфейс в java, взаимодействует с с клиентами посредством принципа запрос-ответ.

    Жизненный цикл сервлета состоит из следующих шагов:

    - В случае отсутствия сервлета в контейнере.
        1) Класс сервлета загружается контейнером.
        2) Контейнер создаёт экземпляр класса сервлета.
        3) Контейнер вызывает метод init(). Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как сервлет сможет обслуживать запросы.
        За весь жизненный цикл метод init() вызывается только один раз.
    - Обслуживание клиентского запроса:
    Каждый запрос обрабатывается в своём отдельном потоке. Контейнер вызывает метод service() для каждого запроса.
    Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки запроса.
    Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не реализован,
    вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
    - В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из эксплуатации.
    Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.
    Сервлет (Java) Wiki https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%BB%D0%B5%D1%82_(Java)
    Документация Servlet
---
---

2. Какова структура веб-проекта?
    в учебе мы используем следующую структуру:
    db/
    src/main/
        java/*/
            config
            controller
            model
            repository
            service
        resources/
            static
            templates
            props
    src/test
        java/*/packetsForTests
        resources/prop
    Introduction to the Standard Directory Layout
---
---

3. Что такое контейнер сервлетов?
    Это часть сервера приложений или веб-сервера, которая управляет жизненным циклом сервлетов,
    обеспечивает их взаимодействие с клиентами и окружением, а также предоставляет различные возможности для разработки веб-приложений на Java.


    Популярные реализации контейнеров сервлетов:

    •	Apache Tomcat
    •	Jetty
    •	GlassFish
    •	WildFly (бывший JBoss)

    Контейнер сервлетов Wiki
    https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80_%D1%81%D0%B5%D1%80%D0%B2%D0%BB%D0%B5%D1%82%D0%BE%D0%B2

    ---
    ---

4. Каковы задачи, функциональность контейнера сервлетов?

    Основные функции контейнера сервлетов:
    1.	Управление жизненным циклом сервлетов: Контейнер создает, инициализирует, обрабатывает запросы и уничтожает сервлеты. Он контролирует все этапы работы сервлета — от его создания до завершения работы.
    2.	Обработка HTTP-запросов: Контейнер принимает HTTP-запросы от клиента (например, веб-браузера), передает их соответствующему сервлету для обработки и возвращает ответ клиенту.
    3.	Управление потоками: Контейнер автоматически создает потоки для обработки каждого запроса, что позволяет сервлетам обрабатывать несколько запросов одновременно.
    4.	Управление безопасностью: Контейнер может контролировать доступ к веб-ресурсам через различные механизмы аутентификации и авторизации (например, использование SSL, ограничение доступа к страницам и т.д.).
    5.	Поддержка сессий: Контейнер сервлетов может управлять сессиями пользователей, отслеживая информацию о пользователях между различными запросами (например, используя cookies или идентификаторы сессий).
    6.	Портируемость и стандарт: Сервлеты работают в соответствии с Java Servlet API, что обеспечивает переносимость веб-приложений между различными сервлет-контейнерами.
---
---

5. Что вы знаете о сервлет фильтрах?

    Это компоненты Java Servlet API, которые позволяют перехватывать и обрабатывать запросы и ответы, проходящие через
    веб-приложение, до того, как они достигают сервлетов или других конечных точек.
    Фильтры используются для выполнения различных задач, таких как аутентификация, логирование, сжатие данных и другие
    операции, которые должны выполняться до или после основного процесса обработки запроса.

    Основные характеристики и задачи фильтров:
	1.	Предобработка запросов: Фильтры могут изменять или логировать данные запроса, например, проверять заголовки,
	параметры или содержимое тела запроса, прежде чем передать его сервлету.
	2.	Постобработка ответов: После того как сервлет завершил обработку, фильтры могут изменять или анализировать ответ,
	например, сжимать данные, добавлять заголовки или вести аудит.
	3.	Цепочка фильтров: Несколько фильтров могут быть связаны друг с другом в цепочку. Каждый фильтр может передавать
	запрос следующему фильтру в цепочке или напрямую конечному компоненту (например, сервлету).
	Это позволяет организовывать обработку в несколько этапов.

    Жизненный цикл фильтров:

    1.	Инициализация (init): Фильтр инициализируется контейнером при запуске приложения.
        Это метод, в котором можно настроить начальные параметры.
    2.	Фильтрация запроса (doFilter): Это основной метод фильтра, который вызывается при каждом запросе. Фильтр может:
        •	изменить запрос,
        •	отклонить его,
        •	передать дальше по цепочке фильтров или непосредственно в сервлет,
        •	обработать ответ после вызова сервлета.
    3.	Уничтожение (destroy): Этот метод вызывается, когда фильтр выгружается из памяти. Обычно это используется для очистки ресурсов.

    Основные задачи фильтров:

    1.	Аутентификация и авторизация: Проверка, имеет ли пользователь права на доступ к ресурсу.
    2.	Логирование и аудит: Сбор информации о запросах и ответах (время, параметры и т.д.).
    3.	Сжатие данных: Сжатие ответов сервера для оптимизации передачи данных (например, использование GZIP).
    4.	Кэширование: Управление кэшированием данных для оптимизации производительности.
    5.	Перенаправление и изменение запросов: Изменение маршрута запроса, добавление или изменение параметров.

    Использование фильтра сервлетов для «всплытия» страницы из фрейма
    https://habr.com/ru/articles/141866/
    The Essentials of Filters
---
---

6. Зачем нужны слушатели в сервлетах?
    Это компоненты, которые отслеживают события в жизненном цикле веб-приложения и выполняют определенные действия в
    ответ на эти события.

    Основные задачи слушателей:

    1.	Инициализация ресурсов: Слушатели могут инициализировать необходимые ресурсы при запуске веб-приложения (например, соединение с базой данных, пул потоков).
    2.	Освобождение ресурсов: При завершении работы приложения слушатели могут закрывать соединения, освобождать память или выполнять другие операции очистки.
    3.	Мониторинг сессий: Слушатели могут отслеживать создание и уничтожение пользовательских сессий, что полезно для управления данными сессий, аутентификацией и персонализацией контента.
    4.	Логирование событий: Слушатели можно использовать для ведения логов ключевых событий приложения, таких как запросы, изменения в сессиях или изменения атрибутов.
    5.	Обработка событий в запросах: Можно отслеживать моменты начала и окончания обработки запросов для выполнения задач, связанных с безопасностью или оптимизацией.

    Типы слушателей:

    1.	ServletContextListener: Отслеживает события, связанные с жизненным циклом контекста веб-приложения (инициализация и завершение работы).
    2.	HttpSessionListener: Отслеживает создание и завершение сессий пользователей.
    3.	ServletRequestListener: Отслеживает события, связанные с жизненным циклом запросов.
    4.	ServletContextAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в контексте веб-приложения.
    5.	HttpSessionAttributeListener: Отслеживает изменения атрибутов сессий.
    6.	ServletRequestAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в запросах.

---
---

7. Когда вы будете использовать фильтры, а когда слушатели?

    •	Используйте фильтры, когда необходимо вмешаться в поток запросов и ответов: изменять, проверять или логировать запросы и ответы на уровне обработки HTTP.
    •	Используйте слушатели, когда нужно отслеживать события на уровне приложения, сессий или запросов, особенно для задач инициализации или управления состоянием.
---
---

8. Как обработать исключения, выброшенные другим сервлетом в приложении?
    1. try catch внутри сервлета
    2. фильтр для перехвата исключений
    3. Использование аннотации @WebServlet и атрибута errorPage

---
---
9. Что такое дескриптор развертывания?

    это конфигурационный файл в Java веб-приложениях, который определяет, как веб-приложение должно быть развернуто и
    настроено в контейнере сервлетов (например, в Tomcat или Jetty).
    Этот файл содержит информацию, которая используется сервером приложений для правильной настройки и работы веб-приложения.

    Дескриптор развёртывания Wiki

---
---

10. Как реализовать запуск сервлета с запуском приложения?
    1. В файле web.xml можно настроить параметр <load-on-startup>, который определяет порядок загрузки сервлета при старте приложения.
    2. Использование аннотации @WebServlet с параметром loadOnStartup
---
---

11. Что представляет собой объект ServletConfig?
    это интерфейс, который предоставляет конфигурационную информацию о конкретном сервлете. Объект ServletConfig передается
    контейнером сервлетов (например, Tomcat или Jetty) при инициализации сервлета и используется для передачи параметров
    инициализации, определенных для конкретного сервлета.
---
---

12. Что представляет собой объект ServletContext?

    это объект, предоставляемый контейнером сервлетов (например, Tomcat, Jetty), который представляет собой глобальную конфигурацию веб-приложения.
    Он позволяет сервлетам взаимодействовать с общими ресурсами и информацией, доступной всему веб-приложению, а не только одному конкретному сервлету
---
---

13. В чем отличия ServletContext и ServletConfig?

	•	ServletConfig: Предоставляет информацию и параметры для конкретного сервлета. Каждый сервлет имеет свой объект ServletConfig.
	•	ServletContext: Представляет все веб-приложение и предоставляет доступ к общим ресурсам и параметрам, которые могут использоваться всеми сервлетами в приложении.
---
---
14. Что такое Request Dispatcher?
    это интерфейс в Java Servlet API, который позволяет сервлетам взаимодействовать друг с другом.
    Он используется для перенаправления запросов или передачи управления другим сервлетам или ресурсам на сервере.

    Основные функции RequestDispatcher:

    	1.	Перенаправление запроса (forward):
    	    •	Текущий сервлет может передать управление другому ресурсу (сервлету, JSP или статическому ресурсу) на сервере.
    	    При этом управление полностью передается другому ресурсу, а клиент не будет знать, что запрос был перенаправлен.
    	2.	Включение содержимого другого ресурса (include):
    	    •	Можно включить результат обработки другого ресурса (например, другой сервлет или JSP-страница) в текущий ответ.
    	    Это позволяет объединять результаты разных ресурсов в один ответ.

    SP (JavaServer Pages) — это технология для создания динамических веб-страниц на Java, которая позволяет встраивать Java-код прямо в HTML-страницы.
    JSP страницы компилируются в сервлеты и обрабатываются сервером, что позволяет динамически генерировать HTML-контент на основе запросов пользователей и данных с сервера.

---
---
Thymeleaf:
1. Расскажите о назначении Thymeleaf?
    Удобный инструмент шаблонизации, явно удобнее чем рисовать страницы с JS

    Учебник Thymeleaf: Глава 1. Знакомство
---
---

2. Расскажите про тег th:text.

    th:text предназначен для динамической подстановки текста (или других данных) в HTML-элемент.
    В отличие от стандартного HTML-тега, который может выводить текст статически, th:text позволяет внедрить данные из
    контроллера или модели Spring, заменяя содержимое HTML-элемента.

    Как работает th:text:

    1.	Статический контент заменяется динамическим: Содержимое тега, где используется th:text, заменяется на значение,
    переданное в модель из контроллера. Это важно для предотвращения вывода статического содержимого и подмены его динамическими данными.
    2.	Обработка данных на стороне сервера: Тег th:text интерпретируется и заполняется на стороне сервера, а не клиента.
    Когда клиент получает готовую страницу, она уже содержит данные, сгенерированные на сервере.

    Учебник Thymeleaf: Глава 3. Использование Text
---
---

3. Расскажите про тег th:if.

    используется для условного отображения элементов на веб-странице.
    Он позволяет вывести элемент только в том случае, если заданное условие является истинным. Это аналог оператора if в java.

    еще есть тег th:unless, он является противоположностью th:if, т.е. производит проверку на false. т.е. отображает
    элемент если условие false.

    Особенности th:if:

    •	Полное удаление элемента: Если условие в th:if не выполняется (т.е. ложное), элемент полностью удаляется из DOM-структуры.
    Это делает его более производительным и удобным для использования, когда нужно скрыть элементы, которые не должны присутствовать на странице.

    Учебник Thymeleaf: Глава 7. Условное выполнение

---
---

4. Расскажите про тег th:href.

    используется для динамического формирования значений атрибута href в HTML-элементах, таких как ссылки (<a>) и другие теги,
    где требуется указать URL. Это позволяет подставлять URL-адреса на основе данных, полученных с сервера, или на основе логики,
    определенной в шаблоне.

    Учебник Thymeleaf: Глава 4. Standard Expression Syntax (Раздел "4.4. Link URL")

---
---

5. Расскажите про тег th:each.

    Используется для работы с коллекциями.
    <h1>Список продуктов</h1>
    <ul>
        <li th:each="product : ${products}" th:text="${product}">Продукт</li>
    </ul>
    В js с эти иначе, там рисование тэга оборачивается в цикл, а тут не недо оборачивать тэг циклом.

    Учебник Thymeleaf: Глава 6.Итерации

---
---

6. Расскажите про тег th:object.

    Используется для удобной работы с полями объекта. нет необходимости каждый раз указывать объект.
    <form th:object="${someObject}">
        <input type="text" th:field="*{fieldName}" />
    </form>

    Руководство: Thymeleaf + Spring. Часть 2 (Раздел "6.1 Обработка командного объекта")

---
---

7. Расскажите про тег th:action.

    Атрибут action определяет, куда будет отправлен запрос при отправке формы.
    так же можно передавать динамические параметры в URL

    Учебник Thymeleaf: Глава 5 Установка значений атрибутов (Раздел "5.2. Установка значения для определенных атрибутов")

---
---

Spring boot:
1. Опишите из каких компонентов состоит Spring boot?
    В обучении используем:
    spring-boot-starter-thymeleaf
    spring-boot-starter-web
    spring-boot-devtools
    spring-boot-starter-actuator
    spring-boot-starter-test

    Введение в Spring Boot: создание простого REST API на Java
    https://habr.com/ru/articles/435144/
---
---

2. Что такое контроллер и как он связан с DispatcherServlet.

    Вся логика работы Spring MVC построена вокруг DispatcherServlet, который принимает и обрабатывает все HTTP-запросы (из UI) и ответы на них.

    - После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой
    Контроллер должен быть вызван, после чего, отправляет запрос в нужный Контроллер.
    - Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST.
    Вызванный метод определяет данные Модели, основанные на определённой бизнес-логике и возвращает в DispatcherServlet имя Вида (View).
    - При помощи интерфейса ViewResolver DispatcherServlet определяет, какой Вид нужно использовать на основании полученного имени.
    - После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид,
    который в конечном итоге отображается в браузере.

    Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver, являются частями интерфейса
    WebApplicationContext extends ApplicationContext, с некоторыми дополнительными особенностями, необходимыми для создания web-приложений.

    Spring MVC — основные принципы (Раздел "DispatcherServlet")
    https://habr.com/ru/articles/336816/
---
---

3. Что такое стереотипные аннотации? Какие они бывают?

    Стереотипы — это аннотации, обозначающие специальную функциональность.
    Все стереотипы включают в себя аннотацию @Component.


    @Component	    Корневая аннотация, которая помечает класс как кандидат для автовнедрения
    @Controller	    Указывает, что класс является контроллером для отправления данных на фронт.
    @RestController	Указывает, что класс является контроллером для REST.
                    Содержит аннотации Controller и @ResponseBody
    @Service	    Указывает, что класс является сервисом для выполнения бизнес-логики
    @Repository	    Указывает, что класс является репозиторием для работы с бд
    @Configuration	Указывает, что класс содержит Java-конфигурацию(@Bean-методы)

    Подготовка к Spring Professional Certification. Контейнер, IoC, бины (Вопрос "Что такое stereotypes")
    https://habr.com/ru/articles/470305/
---
---

4. Что такое DI? Как он реализован в Spring?

    DI (Dependency Injection) — это шаблон проектирования, который используется для управления зависимостями между объектами.
    В контексте DI, зависимость — это объект, от которого зависит другой объект для выполнения своих задач.
    DI решает задачу создания и предоставления этих зависимостей через внешние механизмы, а не непосредственно в коде.

    В Spring Dependency Injection (DI) — это основополагающий принцип, который реализуется через Inversion of Control (IoC) контейнер.
    Контейнер IoC отвечает за создание объектов (бинов), их конфигурацию и управление зависимостями между ними.

    В Spring DI реализован через 3 основных механизма:

        •	Конструкторная инъекция (Constructor Injection)
        •	Инъекция через сеттеры (Setter Injection)
        •	Инъекция полей через аннотации (Field Injection)


    Обратная сторона Spring
    https://habr.com/ru/articles/334448/
---
---

5. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam

    - @ModelAttribute : используется для работы с объектами модели и играет важную роль при передаче данных между контроллером и представлением (view)
        два основных способа использования @ModelAttribute:
        1) как метод в контроллере
            Метод, аннотированный @ModelAttribute, добавляет объект в модель перед выполнением любого метода контроллера, чтобы этот объект был доступен в представлении.
            Это полезно для подготовки данных, которые будут доступны на всех страницах.
            @ModelAttribute("movie")
                public Movie createMovie() {
                    return new Movie();  // Создаем новый объект Movie, который будет доступен в представлении
                }
        2) как параметр метода контроллера
            автоматически связывает данные из HTTP-запроса (например, параметры формы или параметры URL) с полями объекта.
            @PostMapping("/addMovie")
            public String addMovie(@ModelAttribute("movie") Movie movie) {
                // Данные формы автоматически привязываются к объекту Movie
                movieService.saveMovie(movie);
                return "redirect:/movies";
            }

    - @PathVariable : используется для извлечения значений из URL (части пути) и передачи их в метод контроллера.
        @GetMapping("/movie/{id}")
        public String getMovieById(@PathVariable("id") Long movieId, Model model) {
            Movie movie = movieService.getMovieById(movieId);
            model.addAttribute("movie", movie);
            return "movieDetails";
        }

    - @RequestParam : используется для извлечения параметров из строки запроса (query parameters) и передачи их в метод контроллера.
        @GetMapping("/searchMovie")
        public String searchMovie(@RequestParam("title") String title, Model model) {
            List<Movie> movies = movieService.searchByTitle(title);
            model.addAttribute("movies", movies);
            return "searchResults";
        }

    Spring MVC: создание веб-сайтов и RESTful сервисов (Разделы "@PathVariable" и "@RequestParam")
    Spring MVC: создание веб-сайтов и RESTful сервисов (Разделы "@GetMapping" и "Как вы можете управлять загрузкой файлов")
    Подготовка к Spring Professional Certification. Spring REST (Вопрос "Что за аннотации @GetMapping, @PostMapping")
Многопоточность:
1. Объясните, где в веб приложении появляется многопоточность?

    видимо в сервлете, т.к. он всегда создается в единственном экземпляре. Для каждого нового запроса Servlet Container создает
    новый поток для выполнения doGet() или doPost() методов сервлета.

    Конкуренция в сервлетах (Раздел "Обзор")
    https://habr.com/ru/companies/otus/articles/414759/

---
---
2. Как избежать проблем в многопоточности?
   в курсе эта проблема решается с помощью БД, а точнее с помощью параметра unique

---
---
3. Как можно создать блокировку (deadlock) в сервлете?
    Deadlock возникает, когда два (или более) потока оказываются в состоянии взаимного ожидания: каждый из них блокирует ресурс,
    который нужен другому потоку для завершения работы.

---
---
4. Как решать проблемы многопоточности на уровне базы данных?
   в курсе эта проблема решается с помощью БД, а точнее с помощью параметра unique

---
---
Архитектура:
1. Объясните слоеную архитектуру.
    Слой - это классы имеющую одну функциональную принадлежность

    есть слои, путь лежит сверху вниз.
    верхний слой знает что под ним, нижний не знает что над ним.
    принцип инверсии зависимости из SOLID.

    стандартно: controllers -> services -> persistence -> DB
    Слой контроллеры - это классы для работы с клиентом. Эти классы принимают запросы и отдают ответы от клиента.
    Слой сервисы - это классы, выполняющие бизнес логику приложения.
    Слой персистенции - это классы для работы с базами данных.

---
---
2. Объясните шаблон MVC на примере Servlet.

	1.	Пользователь отправляет запрос на URL /users (например, через браузер).
	2.	Контроллер (Servlet) получает этот запрос. Он взаимодействует с моделью (UserService) для получения данных (списка пользователей).
	3.	Контроллер сохраняет эти данные в атрибутах запроса с помощью req.setAttribute("users", users).
	4.	Контроллер перенаправляет запрос на представление (JSP), которое берет данные из атрибутов и отображает их на странице.

3. Объясните шаблон MVC на примере Spring boot.
    Spring MVC — основные принципы
База данных.
1. Зачем нужен пул соединений?

    все запросы от клиентов обрабатываются в отдельных нитях.
    По умолчанию в Tomcat используется 200 нитей для обработки запросов.
    Если мы будем использовать одно соединение с базой данных, то остальные нити будут ждать завершения работы с базой данных,
    а для веб приложений такая ситуация неприемлема.

    Пулы соединений к БД — зачем и почему

---
---

Безопасность.
1. Что такое HttpSession?
    это интерфейс в Java Servlet API, который используется для хранения информации о состоянии между несколькими HTTP-запросами от одного и того же клиента (пользователя).
    особенности:
        1) Персистентность данных между запросами: HttpSession позволяет сохранять данные (например, информацию о пользователе, корзину покупок и т.д.) между несколькими запросами от одного клиента.
        2) Уникальная сессия для каждого клиента: Для каждого клиента создается уникальная сессия, которая хранится на сервере и идентифицируется по специальному идентификатору сессии (Session ID).
        Этот идентификатор обычно хранится в cookie на стороне клиента.
        3) Жизненный цикл сессии: Сессия создается, когда клиент впервые обращается к приложению, и существует до тех пор, пока не истечет время бездействия (тайм-аут),
        клиент явно не завершит сессию или сервер не закроет сессию.

    Spring MVC: создание веб-сайтов и RESTful сервисов (Раздел "Как получить доступ к текущей HttpSession пользователя")
    Документация HttpSession
2. Что такое авторизация?
    проверка что пользователь вообще есть
    Авторизация Wiki
3. Что такое аутентификация?
    подтверждение подлинности пользователя через пароль
    Аутентификация Wiki
4. Что такое cookie?
    Уникальный идентификатор пользователя.
    бывает постоянный и временный.
    используются для удобства пользования ресурсами, т.к. могут хранить в себе индивидуальные настройки и параметры типа корзины.
    «Осторожно, печеньки!»: советы начинающим тестировщикам в сфере безопасности (Раздел "Что хранят cookie")
    Cookie Wiki
6. Опишите аннотации @GetMapping, @PostMapping.
    @GetMapping - указываем что на конкретный путь (URI) отправляется GET запрос и в методе под аннотацией указываем что должно возвращаться пользователю
    @PostMapping - тоже самое только для POST запросов.
